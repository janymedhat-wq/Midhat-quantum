<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Dynamics Engine: 3rd-Gen Double-Slit</title>
    <!-- Importing a new, modern font: Space Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <!-- MathJax for LaTeX typesetting -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        /* General body styles for a light, minimalist theme */
        body {
            font-family: 'Space Mono', monospace;
            background-color: #f0f0f0;
            color: #111;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Dark theme styles */
        body.dark-theme {
            background-color: #111;
            color: #f0f0f0;
        }

        body.dark-theme .tutorial-content { border-top: 1px solid #444; }
        body.dark-theme pre { background-color: #222; }
        body.dark-theme .theme-toggle-button { color: #f0f0f0; border-color: #f0f0f0; }
        body.dark-theme .theme-toggle-button:hover { background-color: #f0f0f0; color: #111; }
        body.dark-theme .equation-block { border-left: 3px solid #7cb3ff; background-color: #222; }
        body.dark-theme figcaption { color: #ccc; }
        body.dark-theme .main-content h1 { color: #f0f0f0; }

        /* Container for the main content */
        .container {
            flex-grow: 1;
            padding: clamp(30px, 5vw, 50px);
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        /* --- Main Text Section --- */
        .main-content h1 {
            font-family: 'Space Mono', monospace;
            font-size: clamp(3rem, 10vw, 7rem);
            line-height: 1;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 5px;
            color: #111;
        }
        
        /* --- Tutorial Section Styles --- */
        .tutorial-content {
            margin-top: clamp(50px, 10vw, 100px);
            padding-top: clamp(25px, 5vw, 50px);
            border-top: 1px solid #c0c0c0;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: clamp(20px, 5vw, 40px);
        }
        .tutorial-content p { line-height: 1.6; max-width: 800px; }
        .tutorial-content h2, .tutorial-content h3, .tutorial-content h4 { font-weight: 700; text-transform: uppercase; }
        .tutorial-content h2 { font-size: clamp(1.5rem, 4vw, 2rem); letter-spacing: 2px; }
        .tutorial-content h3 { font-size: clamp(1rem, 2vw, 1.2rem); margin-top: 2rem; margin-bottom: 1rem; }
        
        pre { background-color: #e5e7eb; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; width: 100%; box-sizing: border-box; }
        pre code { font-size: 0.9rem; }

        /* Style for LaTeX equations */
        .equation-block {
            padding: 10px;
            margin: 1.5rem 0;
            border-left: 3px solid #007bff;
            background-color: #f8f9fa;
        }
        
        /* Image/Visualization Styling */
        .viz-container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto; /* Centering the visualization */
            border: 1px solid #ccc;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            padding: 0;
        }
        body.dark-theme .viz-container { border-color: #444; box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        
        .viz-container img {
            width: 100%;
            height: auto;
            display: block;
            min-height: 200px; /* Ensure placeholder visibility */
        }
        .viz-container figcaption {
            padding: 10px;
            font-size: 0.8rem;
            text-align: center;
            background-color: #f8f8f8;
        }
        body.dark-theme .viz-container figcaption {
            background-color: #282828;
        }
        
        /* --- Footer and Theme Toggle --- */
        footer {
            margin-top: auto;
            padding: 30px clamp(30px, 5vw, 50px);
            border-top: 1px solid #c0c0c0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .theme-toggle-button {
            background: none; border: 1px solid #111; color: #111; padding: 8px 16px;
            font-family: 'Space Mono', monospace; font-size: 0.9rem; cursor: pointer;
            transition: background-color 0.3s ease, color: 0.3s ease; border-radius: 5px;
            display: flex; align-items: center; gap: 8px; text-transform: uppercase;
        }
        .theme-toggle-button:hover { background-color: #111; color: #f0f0f0; }
        .dark-theme .theme-toggle-button { border: 1px solid #f0f0f0; color: #f0f0f0; }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 30px; text-align: center; align-items: center; }
            footer { flex-direction: column; justify-content: center; align-items: center; gap: 10px; }
            .main-content h1 { letter-spacing: 2px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Main content area -->
        <div class="main-content">
            <h1>QUANTUM DYNAMICS ENGINE</h1>
        </div>

        <!-- Tutorial Section (Core Technical Content) -->
        <main class="tutorial-content">
            <h2 class="books-title">3RD-GEN DOUBLE-SLIT: W-FUNCTION PROPAGATION AND DECOHERENCE</h2>
            <p class="text-sm text-gray-500">
                This framework simulates the full **time evolution** of the quantum state, incorporating particle-particle interactions (Bosons/Fermions) and environmental effects (Decoherence) across 1D, 2D, or 3D grids.
            </p>

            <div class="content-section">
                <p>
                    The 3rd-Generation Double-Slit extends the classical experiment by solving the full **Time-Dependent Schrödinger Equation (TDSE)**, allowing observation of the wave packet spreading and its interaction with the slit potential barrier over time. This requires highly efficient numerical propagation techniques, such as the **Split-Step Fourier Method (SSFM)**.
                </p>
                <div class="viz-container">
                    <!-- Placeholder image to represent the Time Evolution Visualization -->
                    <img src="3D_Quantum_DoubleSlit.gif"
                          alt="2D visualization of the double-slit wavefunction propagating over time."
                          onerror="this.onerror=null; this.src='https://placehold.co/800x400/DC2626/FFFFFF?text=2D+Wavefunction+Time+Evolution+|^2';"/>
                    <figcaption>Conceptual visualization of the probability density $|\Psi|^2$ propagating through two slits over a finite time interval.</figcaption>
                </div>

                <h3>1. The Physics: Time Evolution and Decoherence</h3>
                <p>
                    The core challenge is propagating the wave function $\Psi(\mathbf{r}, t)$ forward in time. For an isolated system, the TDSE applies. To model environmental effects (which destroy interference), we use the **Quantum Master Equation** or the **Lindblad Operator** to introduce dissipation.
                </p>
                
                <h4 id="hamiltonian">The Time-Dependent Schrödinger Equation (TDSE)</h4>
                <div class="equation-block">
                    $$i\hbar \frac{\partial}{\partial t} \Psi(\mathbf{r}, t) = \hat{H} \Psi(\mathbf{r}, t)$$
                    $$\hat{H} = -\frac{\hbar^2}{2m} \nabla^2 + V_{\text{slits}}(\mathbf{r})$$
                </div>
                <p>
                    Where $V_{\text{slits}}$ represents the potential barrier defining the two slits. In the SSFM, the exponential time evolution operator $e^{-i\hat{H} \Delta t/\hbar}$ is split into kinetic ($\hat{T}$) and potential ($\hat{V}$) components.
                </p>

                <h3>2. C++ Kernel Concept: Split-Step Fourier Propagation</h3>
                <p>
                    The SSFM is ideally suited for HPC using the **Fast Fourier Transform (FFT)**, which is highly optimized on GPUs (e.g., using **cuFFT**). Propagation involves three steps per time slice: apply $V$ (in real space), transform to momentum space, apply $T$ (in momentum space), and transform back.
                </p>
                
                <h4 id="cuda-kernel">Conceptual CUDA Kernel for SSFM (3D Dynamics)</h4>
                <pre class="code-snippet"><code class="language-cpp">// kernel_tdse_propagation.cu: SSFM Time Stepping Core
#include <cuComplex.h> // For complex number operations
#define N_GRID_POINTS (NX * NY * NZ)

// Utility: Apply the Potential Operator V in Real Space
__global__ void apply_potential_kernel(cuComplex* psi, const double* potential, double dt) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N_GRID_POINTS) {
        // H_V = exp(-i * V * dt / hbar)
        // Assume hbar=1 for simulation units
        double phase = -potential[idx] * dt;
        double cos_val = cos(phase);
        double sin_val = sin(phase);
        
        // Multiply psi by the complex phase factor
        cuComplex phase_factor = make_cuComplex(cos_val, sin_val);
        psi[idx] = cuCmul(psi[idx], phase_factor);
    }
}

// Utility: Apply the Kinetic Operator T in Momentum Space (after FFT)
// T_k = exp(-i * (hbar^2 * k^2 / (2m)) * dt / hbar)
__global__ void apply_kinetic_kernel(cuComplex* psi_k, const double* kinetic_dispersion, double dt) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < N_GRID_POINTS) {
        // kinetic_dispersion[idx] holds the value of (hbar^2 * k^2 / (2m))
        // k^2 is dependent on the 3D momentum index
        double phase = -kinetic_dispersion[idx] * dt;
        double cos_val = cos(phase);
        double sin_val = sin(phase);
        
        // Multiply the momentum-space wavefunction psi_k by the complex phase factor
        cuComplex phase_factor = make_cuComplex(cos_val, sin_val);
        psi_k[idx] = cuCmul(psi_k[idx], phase_factor);
    }
}

// Main propagation loop: Uses cuFFT calls between kernel steps
void ssfm_propagate(cuComplex* psi, double dt) {
    // 1. Apply V/2 (Half-step)
    apply_potential_kernel<<<...>>>(psi, potential_data, dt / 2.0);
    
    // 2. FFT to momentum space
    // cufftExecC2C(fft_plan, psi, psi, CUFFT_FORWARD); 

    // 3. Apply T (Full-step)
    apply_kinetic_kernel<<<...>>>(psi, kinetic_dispersion_data, dt);
    
    // 4. Inverse FFT back to real space
    // cufftExecC2C(fft_plan, psi, psi, CUFFT_INVERSE);

    // 5. Apply V/2 (Half-step)
    apply_potential_kernel<<<...>>>(psi, potential_data, dt / 2.0);
}

// End of C++ Kernel Concept.</code></pre>

                <h3>3. Python Control: Initialization and Statistics</h3>
                <p>
                    Python serves as the high-level controller, defining the geometry, initializing the wave packet, and analyzing the final detection statistics. This allows for runtime switching between 1D, 2D, and 3D geometries and configuring **particle statistics** (e.g., using density matrix methods for Bosonic condensate dynamics).
                </p>

                <h4 id="python-analysis">Python Setup and Simulation Control</h4>
                <pre class="code-snippet"><code class="language-python"># python_simulation_controller.py: Setup and Analysis Interface
import numpy as np

class QuantumEngineController:
    """Manages simulation parameters, initial conditions, and analysis."""
    
    def __init__(self, dimension, grid_size, time_step):
        self.D = dimension
        self.N_grid = grid_size
        self.dt = time_step
        self.state = 'UNINITIALIZED'
        print(f"Engine initialized for {self.D}D space with {self.N_grid**self.D} grid points.")

    def define_geometry(self, slit_width, slit_separation):
        """Sets up the potential barrier geometry."""
        # This function would discretize the barrier potential V_slits onto the grid
        self.V_slits = np.zeros(self.N_grid**self.D)
        # --- Conceptual Slit Definition Logic ---
        # e.g., Set V_slits = V_max in areas corresponding to the barrier material
        # and V_slits = 0 in the slit regions.
        
        print(f"Geometry defined: W={slit_width}, S={slit_separation}")
        return self.V_slits

    def initialize_wave_packet(self, position, momentum, width):
        """Creates the initial Gaussian wave packet at time t=0."""
        # Creates a complex array representing Psi(r, t=0)
        # This state is then passed to the CUDA kernel for propagation.
        
        initial_psi = np.exp(-((np.arange(self.N_grid) - position) / width)**2) * \
                      np.exp(1j * momentum * np.arange(self.N_grid))
        self.state = 'INITIALIZED'
        print("Wave packet initialized successfully.")
        return initial_psi

    def analyze_detection_screen(self, final_psi):
        """Calculates the probability distribution at the detection screen."""
        # The probability density is |\Psi|^2
        probability_density = np.abs(final_psi)**2
        
        # Calculate the interference visibility (V = (I_max - I_min) / (I_max + I_min))
        I_max = np.max(probability_density)
        I_min = np.min(probability_density)
        visibility = (I_max - I_min) / (I_max + I_min)
        
        print("-" * 40)
        print(f"Detection Analysis Complete. Phase: Interference")
        print(f"Interference Visibility (V): {visibility: .4f}")
        print("-" * 40)
        return visibility

# Example usage (2D, 256x256 grid)
# engine = QuantumEngineController(dimension=2, grid_size=256, time_step=0.001)
# potential = engine.define_geometry(slit_width=5, slit_separation=20)
# initial_psi = engine.initialize_wave_packet(position=50, momentum=0.5, width=10)

# End of Python Simulation Controller.</code></pre>
            </div>
        </main>
    </div>

    <!-- The Footer remains outside the container to span full width -->
    <footer>
        <p>© 2025 Quantum Dynamics Engine Technical Document.</p>
        <!-- Theme Toggle Button -->
        <button id="theme-toggle" class="theme-toggle-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
            <span id="theme-text">Dark Mode</span>
        </button>
    </footer>

    <!-- JavaScript for Theme Toggle Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');

            // --- Theme Toggle Logic ---
            const initialTheme = localStorage.getItem('theme') || 'light';
            const isDarkMode = initialTheme === 'dark';

            const updateThemeUI = (isDark) => {
                // SVG for sun (light mode icon)
                const svgSun = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>`;
                // SVG for moon (dark mode icon)
                const svgMoon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>`;

                if (isDark) {
                    body.classList.add('dark-theme');
                    toggleButton.innerHTML = `${svgMoon}<span>Light Mode</span>`;
                } else {
                    body.classList.remove('dark-theme');
                    toggleButton.innerHTML = `${svgSun}<span>Dark Mode</span>`;
                }
            };

            updateThemeUI(isDarkMode);

            toggleButton.addEventListener('click', () => {
                const isDark = body.classList.toggle('dark-theme');
                localStorage.setItem('theme', isDark ? 'dark' : 'light');
                updateThemeUI(isDark);
            });
        });
    </script>
</body>
</html>